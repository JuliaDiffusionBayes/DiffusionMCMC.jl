var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMC]","category":"page"},{"location":"module_index/#DiffusionMCMC.DiffusionMCMCBackend","page":"Index","title":"DiffusionMCMC.DiffusionMCMCBackend","text":"GenericMCMCBackend\n\nA flag that no specific backend is passed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingChequerboardSwitch","page":"Index","title":"DiffusionMCMC.BlockingChequerboardSwitch","text":"BlockingChequerboardSwitch <: BlockingType\n\nA decorator indicating a switch (in a chequerboard pattern) that changes the locations of delimiters of blocks.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingType","page":"Index","title":"DiffusionMCMC.BlockingType","text":"BlockingType <: MCMCUpdateDecorator\n\nSupertype of all blocking patterns.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.DiffusionSpecificCallback","page":"Index","title":"DiffusionMCMC.DiffusionSpecificCallback","text":"DiffusionSpecificCallback <: Callback\n\nSupertype of all callbacks specific to diffusion processes.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMC.init_paths!","text":"init_paths!(P, WW, Wnr, XX, data)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Get started","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Installation-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionMCMC.jl","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"note: Note\nThe package depends on DiffusionDefinition.jl, ObservationSchemes.jl, GuidedProposals.jl and ExtensibleMCMC.jl neither of which is registered yet. Install them in the same way as DiffusionMCMC.jl.","category":"page"},{"location":"get_started/overview/#Preparation-1","page":"Get started","title":"Preparation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To use the MCMC samplers implemented in DiffusionMCMC.jl you should define a target and auxiliary diffusions using DiffusionDefinition.jl and put your data in the format of AllObservations from ObservationSchemes.jl, for instance:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals, DiffusionDefinition\nusing ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Random, Plots\nusing OrderedCollections\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# let's prepare the data\nrecording = (\n\tP = P,\n\tobs = load_data(\n\t\tObsScheme(\n\t\t\tLinearGsnObs(\n\t\t\t\t0.0, (@SVector [0.0]);\n\t\t\t\tL=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n\t\t\t)\n\t\t),\n\t\tdata\n\t),\n\tt0 = 0.0,\n\tx0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"get_started/overview/#The-underlying-idea-1","page":"Get started","title":"The underlying idea","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Just as in ExtensibleMCMC.jl you may define a variety of MCMC algorithms by deciding on a sequence of updates that constitute each of its steps. You have a verity of options to choose from:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"for updating the parameters of a diffusion you may choose any step from ExtensibleMCMC.jl\nfor imputing the path on the other hand you may choose anything from a set of updates implemented in this package.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define your MCMC algorithm you should simply pass a list of such updates to the MCMC object.","category":"page"},{"location":"get_started/overview/#Smoothing-1","page":"Get started","title":"Smoothing","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Parameters are known and fixed, so simply path an imputation flag PathImputation to MCMC:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :none => -Inf, # no parameters needed for smoothing\n\t),\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Parameter-inference-1","page":"Get started","title":"Parameter inference","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"In addition to imputation step pass a parameter update step to define a suitable Metropolis-within-Gibbs algorithm","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)\n\n# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)\n\n\n# and do the inference\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.2]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :REC1_s => -0.8, # param 1\n\t),\n    callbacks = eMCMC.Callback[],\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Adaptive-schemes-1","page":"Get started","title":"Adaptive schemes","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Blocking-1","page":"Get started","title":"Blocking","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Printing-Callback-1","page":"Get started","title":"Printing Callback","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Plotting-Callback-with-[DiffusionMCMCPlots.jl](https://github.com/JuliaDiffusionBayes/DiffusionMCMCPlots.jl)-1","page":"Get started","title":"Plotting Callback with DiffusionMCMCPlots.jl","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#[ExtensibleMCMC.jl](https://github.com/JuliaDiffusionBayes/ExtensibleMCMC.jl)-functionality-1","page":"Get started","title":"ExtensibleMCMC.jl functionality","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"how_to_guides/smoothing/#how_to_guides_start-1","page":"(TODO) Do smoothing","title":"How to do smoothing?","text":"","category":"section"},{"location":"how_to_guides/smoothing/#","page":"(TODO) Do smoothing","title":"(TODO) Do smoothing","text":"","category":"page"},{"location":"how_to_guides/blocking/#How-to-do-blocking?-1","page":"(TODO) Do blocking","title":"How to do blocking?","text":"","category":"section"},{"location":"how_to_guides/blocking/#","page":"(TODO) Do blocking","title":"(TODO) Do blocking","text":"","category":"page"},{"location":"manual/workspaces/#Workspaces-1","page":"Diffusion Workspaces","title":"Workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Workspaces are containers on which most of the computations done by the MCMC algorithm are performed. It is not important to know how this work is dealt with internally; however, it is helpful to know what are the entries of the global and local workspace for diffusions, as the output of the call to run! is precisely that:","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"the DiffusionGlobalWorkspace, as well as\nDiffusionLocalWorkspace for each update.","category":"page"},{"location":"manual/workspaces/#Global-workspaces-1","page":"Diffusion Workspaces","title":"Global workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Global workspace holds information about the history of the parameters (both accepted and proposed) as well as some standard, already pre-computed statistics about the chain.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionGlobalSubworkspace\nDiffusionMCMC.DiffusionGlobalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalSubworkspace","text":"struct DiffusionGlobalSubworkspace{T,TGP,TW,TWn,TX} <: eMCMC.GlobalWorkspace{T}\n    P::TGP\n    WW::TW\n    Wnr::TWn\n    XX::TX\nend\n\nConvenience sub-workspace that holds\n\nP::Vector{<:Vector{<:GuidProp}}: the GuidProp laws [TODO change to PP or                                    PPP]\nWW::Vector{<:Vector{<:Trajectory}}: the containers for sampling the Wiener                                       noise\nWnr::Vector{<:Wiener}: the flags for the Wiener noise\nXX::Vector{<:Vector{<:Trajectory}}: the containers for sampling the                                       diffusion paths\n\nThe outer array corresponds to successive recordings, the inner arrays correspond to successive observations within each recording. Each DiffusionSubworkspace has two DiffusionGlobalSubworkspaces, one for the accepted law/path another for the proposal.\n\nDiffusionGlobalSubworkspace{T}(\n    aux_laws, data::AllObservations, tts, args,\n) where T\n\nA standard constructor. aux_laws is a list of auxiliary laws (one for each recording), data holds the observations, tts are the time-grids on which to do imputation when sampling and args are additional positional arguments passed to initializers of GuidProp.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalWorkspace","text":"struct DiffusionGlobalWorkspace{T,SW,SWD,TD,TX} <: eMCMC.GlobalWorkspace{T}\n    sub_ws::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    data::TD\n    stats::GenericChainStats{T}\n    XX_buffer::TX\n    pnames::Vector{Symbol}\nend\n\nGlobal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericGlobalSubworkspace from ExtensibleMCMC that stores info           about the parameter chain\nsub_ws_diff: DiffusionGlobalSubworkspace containers for the accepted                diffusion law/paths\nsub_ws_diff°: DiffusionGlobalSubworkspace containers for the proposed                 diffusion law/paths\ndata: observations\nstats::GenericChainStats: generic online statistics for the param chain\nXX_buffer: cache for saving a chain of paths\npnames: a list of parameter names that are being updated\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#Local-workspaces-1","page":"Diffusion Workspaces","title":"Local workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Local workspaces hold information pertinent to particular updates. In particular it collects such information as acceptance history or a history of log-likelihoods.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionLocalSubworkspace\nDiffusionMCMC.DiffusionLocalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalSubworkspace","text":"struct DiffusionLocalSubworkspace{T,TP,TW,TWn,TX,Tz0} <: eMCMC.LocalWorkspace{T}\n    ll::Vector{Float64}\n    ll_history::Vector{Vector{Float64}}\n    P::TP\n    WW::TW\n    Wnr::TWn\n    XX::TX\n    z0s::Tz0\nend\n\nConvenience sub-workspace that holds\n\nll::Vector{Float64}: computational buffer for log-likelihoods (one for each                        recording)\nll_history::Vector{Vector{Float64}}:  history of all log-likelihoods\nP: appropriately shaped views to containers with GuidProps\nWW: appropriately shaped views to containers for sampled Wiener process\nWnr: list of Wiener flags for each recording\nXX: appropriately shaped views to containers for sampled diffusion paths\nz0s: list of white noise for starting points (one for each recording)\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalWorkspace","text":"struct DiffusionLocalWorkspace{T,SW,SWD,Tpr} <: eMCMC.LocalWorkspace{T}\n    sub_ws::SW\n    sub_ws°::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    xx0_priors::Tpr\n    acceptance_history::Vector{Vector{Bool}}\n    loc_pnames::LocalUpdtParamNames\n    critical_param_change::Vector{Bool}\nend\n\nLocal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericLocalSubworkspace from ExtensibleMCMC that acts as a           local cache for some light parameter computations\nsub_ws°: same as sub_ws, but concerns the proposed parameter\nsub_ws_diff: DiffusionLocalSubworkspace, views to containers for the                accepted diffusion law/paths\nsub_ws_diff°: DiffusionLocalSubworkspace, views to containers for the                 proposed diffusion law/paths\nxx0_priors: priors over starting points\nacceptance_history: history of results from the accept/reject                       Metropolis–Hastings step\nloc_pnames: various lists of parameter names helping in performing the               update in a clean way\ncritical_param_change: a list of flags for whether a given update by itself                          prompts for recomputation of the guiding term\n\n\n\n\n\n","category":"type"},{"location":"manual/blocking/#Blocking-1","page":"(TODO) Blocking","title":"Blocking","text":"","category":"section"},{"location":"manual/blocking/#","page":"(TODO) Blocking","title":"(TODO) Blocking","text":"","category":"page"},{"location":"manual/callbacks/#Callbacks-1","page":"(TODO) Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/#","page":"(TODO) Callbacks","title":"(TODO) Callbacks","text":"","category":"page"},{"location":"manual/updates_and_decorators/#manual_start-1","page":"Updates & Decorators","title":"Updates & decorators","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"An important category of updates for DiffusionMCMC.jl are:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.MCMCDiffusionImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.MCMCDiffusionImputation","page":"Updates & Decorators","title":"DiffusionMCMC.MCMCDiffusionImputation","text":"MCMCDiffusionImputation <: MCMCImputation\n\nSupertype of all imputations related to diffusions.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"These are essential for imputing the unobserved parts of the path, as well as sampling the starting point. The following imputation steps have been implemented.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.PathImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.PathImputation","page":"Updates & Decorators","title":"DiffusionMCMC.PathImputation","text":"struct PathImputation{T} <: MCMCDiffusionImputation\n    ρs::Vector{Vector{T}}\n    aux_laws\nend\n\nUpdate type. An indicator for imputation of unobserved path segments. ρs are the memory parameters for the preconditioned Crank–Nicolson scheme and aux_laws are the laws for the auxiliary diffusions.\n\nPathImputation(ρ::T, P) where T<:Number\n\nBase constructor v1. Initialize all ρs with the same value ρ and set auxiliary laws to P.\n\nPathImputation(ρ::T, P) where T<:Vector\n\nBase constructor v2. Initialize each recording with its own value of ρ and set auxiliary laws to P.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/inference_fpt/#Inference-in-a-first-passage-time-setting-1","page":"(TODO) Inference from first-passage time observations","title":"Inference in a first-passage time setting","text":"","category":"section"},{"location":"tutorials/inference_fpt/#","page":"(TODO) Inference from first-passage time observations","title":"(TODO) Inference from first-passage time observations","text":"","category":"page"},{"location":"manual/how_extend/#The-underlying-structure-1","page":"Extension of ExtensibleMCMC.jl","title":"The underlying structure","text":"","category":"section"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"","category":"page"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"DiffusionMCMC.jl is at its core an extension of ExtensibleMCMC.jl. Consequently, the way of interacting with the package follows closely how it was presented in here. In particular, the list of parameter updates remains unchanged, it is merely extended with additional steps pertinent to imputation of the paths.","category":"page"},{"location":"tutorials/mixed_effects_models/#Mixed-effects-models-1","page":"(TODO) Mixed-effect models","title":"Mixed-effects models","text":"","category":"section"},{"location":"tutorials/mixed_effects_models/#","page":"(TODO) Mixed-effect models","title":"(TODO) Mixed-effect models","text":"","category":"page"},{"location":"#DiffusionMCMC.jl-1","page":"Home","title":"DiffusionMCMC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bayesian inference for diffusion processes via MCMC sampling. It's an extension of ExtensibleMCMC.jl to diffusion processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"All algorithms provided in ExtensibleMCMC.jl work here as well and do inference for diffusions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of DiffusionMCMC.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionMCMC.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"tutorials/simple_inference/#tutorials_start-1","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference and smoothing for the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"In this tutorial we will do smoothing and parameter inference of the partially observed hypoelliptic version of the FitzHugh–Nagumo model.","category":"page"},{"location":"tutorials/simple_inference/#Preparation-1","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Preparation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals, DiffusionDefinition\nusing ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Random, Plots\nusing OrderedCollections\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# let's prepare the data\nrecording = (\n\tP = P,\n\tobs = load_data(\n\t\tObsScheme(\n\t\t\tLinearGsnObs(\n\t\t\t\t0.0, (@SVector [0.0]);\n\t\t\t\tL=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n\t\t\t)\n\t\t),\n\t\tdata\n\t),\n\tt0 = 0.0,\n\tx0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/simple_inference/#Smoothing-1","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Smoothing","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :none => -Inf, # no parameters needed for smoothing\n\t),\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#Inference-1","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh Nagumo model","title":"Inference & smoothing for the FitzHugh Nagumo model","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)\n\n# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)\n\n\n# and do the inference\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.2]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :REC1_s => -0.8, # param 1\n\t),\n    callbacks = eMCMC.Callback[],\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"}]
}
