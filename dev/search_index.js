var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMC]","category":"page"},{"location":"module_index/#DiffusionMCMC.AdaptationPathImputation","page":"Index","title":"DiffusionMCMC.AdaptationPathImputation","text":"mutable struct AdaptationPathImputation <: eMCMC.Adaptation\n    proposed::Int64\n    accepted::Int64\n    target_accpt_rate::Float64\n    adapt_every_k_steps::Int64\n    scale::Float64\n    min::Float64\n    max::Float64\n    offset::Float64\nend\n\nA struct containing information about the way in which to adapt the memory parameter of the preconditioned Crank–Nicolson scheme. proposed and accepted are the internal counters that keep track of the number of proposed and accepted samples. target_accpt_rate is the acceptance rate of the Metropolis-Hastings steps that is supposed to be targetted. min is used to enforce the minimal allowable range that the random walker can sample from, max enforces the maximum. offset introduces some delay in the start of decelerting the adaptation extent and scale is a scaling parameter for adaptation speed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.DiffusionMCMCBackend","page":"Index","title":"DiffusionMCMC.DiffusionMCMCBackend","text":"GenericMCMCBackend\n\nA flag that no specific backend is passed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingChequerboardSwitch","page":"Index","title":"DiffusionMCMC.BlockingChequerboardSwitch","text":"BlockingChequerboardSwitch <: BlockingType\n\nA decorator indicating a switch (in a chequerboard pattern) that changes the locations of delimiters of blocks.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingType","page":"Index","title":"DiffusionMCMC.BlockingType","text":"BlockingType <: MCMCUpdateDecorator\n\nSupertype of all blocking patterns.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.DiffusionSpecificCallback","page":"Index","title":"DiffusionMCMC.DiffusionSpecificCallback","text":"DiffusionSpecificCallback <: Callback\n\nSupertype of all callbacks specific to diffusion processes.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DataStructures.reset!-Tuple{AdaptationPathImputation}","page":"Index","title":"DataStructures.reset!","text":"reset!(adpt::AdaptationPathImputation)\n\nReset the number of proposals and accepted samples to zero.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMC.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMC.init_paths!","text":"init_paths!(P, WW, Wnr, XX, data)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate!-Tuple{AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.acceptance_rate!","text":"acceptance_rate!(adpt::AdaptationPathImputation)\n\nDestructive computation of a current acceptance rate that also resets the number of proposals and accepted samples to zeros.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate-Tuple{AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.acceptance_rate","text":"acceptance_rate(adpt::AdaptationPathImputation)\n\nCompute current acceptance rate of the Metropolis-Hastings update step\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.readjust!","page":"Index","title":"ExtensibleMCMC.readjust!","text":"readjust!(\n    imp::PathImputation, adpt::AdaptationPathImputation, mcmc_iter, i=1\n)\n\nAdaptive readjustment for the ith recording of the preconditioned Crank–Nicolson scheme's memory parameter.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.register!-Tuple{Any,AdaptationPathImputation,Bool,Any}","page":"Index","title":"ExtensibleMCMC.register!","text":"register!(updt, adpt::AdaptationPathImputation, accepted::Bool, ::Any)\n\nRegister the result of the acceptance decision in the Metropolis-Hastings step.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.time_to_update-Tuple{Val{true},AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.time_to_update","text":"time_to_update(::Val{true}, adpt::AdaptationPathImputation)\n\nReturn true if it's the time to update the memory parameter of the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Get started","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Installation-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionMCMC.jl","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"note: Note\nThe package depends on DiffusionDefinition.jl, ObservationSchemes.jl, GuidedProposals.jl and ExtensibleMCMC.jl neither of which is registered yet. Install them in the same way as DiffusionMCMC.jl.","category":"page"},{"location":"get_started/overview/#Preparation-1","page":"Get started","title":"Preparation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To use the MCMC samplers implemented in DiffusionMCMC.jl you should define a target and auxiliary diffusions using DiffusionDefinition.jl and put your data in the format of AllObservations from ObservationSchemes.jl, for instance:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals, DiffusionDefinition\nusing ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Random, Plots\nusing OrderedCollections\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# let's prepare the data\nrecording = (\n\tP = P,\n\tobs = load_data(\n\t\tObsScheme(\n\t\t\tLinearGsnObs(\n\t\t\t\t0.0, (@SVector [0.0]);\n\t\t\t\tL=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n\t\t\t)\n\t\t),\n\t\tdata\n\t),\n\tt0 = 0.0,\n\tx0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"get_started/overview/#The-underlying-idea-1","page":"Get started","title":"The underlying idea","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Just as in ExtensibleMCMC.jl you may define a variety of MCMC algorithms by deciding on a sequence of updates that constitute each of its steps. You have a verity of options to choose from:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"for updating the parameters of a diffusion you may choose any step from ExtensibleMCMC.jl\nfor imputing the path on the other hand you may choose anything from a set of updates implemented in this package.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define your MCMC algorithm you should simply pass a list of such updates to the MCMC object.","category":"page"},{"location":"get_started/overview/#Smoothing-1","page":"Get started","title":"Smoothing","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Parameters are known and fixed, so simply path an imputation flag PathImputation to MCMC:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :none => -Inf, # no parameters needed for smoothing\n\t),\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Parameter-inference-1","page":"Get started","title":"Parameter inference","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"In addition to imputation step pass a parameter update step to define a suitable Metropolis-within-Gibbs algorithm","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)\n\n# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)\n\n\n# and do the inference\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.2]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :REC1_s => -0.8, # param 1\n\t),\n    callbacks = eMCMC.Callback[],\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Adaptive-schemes-1","page":"Get started","title":"Adaptive schemes","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Blocking-1","page":"Get started","title":"Blocking","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Printing-Callback-1","page":"Get started","title":"Printing Callback","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Plotting-Callback-with-[DiffusionMCMCPlots.jl](https://github.com/JuliaDiffusionBayes/DiffusionMCMCPlots.jl)-1","page":"Get started","title":"Plotting Callback with DiffusionMCMCPlots.jl","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#[ExtensibleMCMC.jl](https://github.com/JuliaDiffusionBayes/ExtensibleMCMC.jl)-functionality-1","page":"Get started","title":"ExtensibleMCMC.jl functionality","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"how_to_guides/smoothing/#how_to_guides_start-1","page":"(TODO) Do smoothing","title":"How to do smoothing?","text":"","category":"section"},{"location":"how_to_guides/smoothing/#","page":"(TODO) Do smoothing","title":"(TODO) Do smoothing","text":"","category":"page"},{"location":"how_to_guides/blocking/#How-to-do-blocking?-1","page":"(TODO) Do blocking","title":"How to do blocking?","text":"","category":"section"},{"location":"how_to_guides/blocking/#","page":"(TODO) Do blocking","title":"(TODO) Do blocking","text":"","category":"page"},{"location":"manual/workspaces/#Workspaces-1","page":"Diffusion Workspaces","title":"Workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Workspaces are containers on which most of the computations done by the MCMC algorithm are performed. It is not important to know how this work is dealt with internally; however, it is helpful to know what are the entries of the global and local workspace for diffusions, as the output of the call to run! is precisely that:","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"the DiffusionGlobalWorkspace, as well as\nDiffusionLocalWorkspace for each update.","category":"page"},{"location":"manual/workspaces/#Global-workspaces-1","page":"Diffusion Workspaces","title":"Global workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Global workspace holds information about the history of the parameters (both accepted and proposed) as well as some standard, already pre-computed statistics about the chain.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionGlobalSubworkspace\nDiffusionMCMC.DiffusionGlobalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalSubworkspace","text":"struct DiffusionGlobalSubworkspace{T,TGP,TW,TWn,TX} <: eMCMC.GlobalWorkspace{T}\n    P::TGP\n    WW::TW\n    Wnr::TWn\n    XX::TX\nend\n\nConvenience sub-workspace that holds\n\nP::Vector{<:Vector{<:GuidProp}}: the GuidProp laws [TODO change to PP or                                    PPP]\nWW::Vector{<:Vector{<:Trajectory}}: the containers for sampling the Wiener                                       noise\nWnr::Vector{<:Wiener}: the flags for the Wiener noise\nXX::Vector{<:Vector{<:Trajectory}}: the containers for sampling the                                       diffusion paths\n\nThe outer array corresponds to successive recordings, the inner arrays correspond to successive observations within each recording. Each DiffusionSubworkspace has two DiffusionGlobalSubworkspaces, one for the accepted law/path another for the proposal.\n\nDiffusionGlobalSubworkspace{T}(\n    aux_laws, data::AllObservations, tts, args,\n) where T\n\nA standard constructor. aux_laws is a list of auxiliary laws (one for each recording), data holds the observations, tts are the time-grids on which to do imputation when sampling and args are additional positional arguments passed to initializers of GuidProp.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalWorkspace","text":"struct DiffusionGlobalWorkspace{T,SW,SWD,TD,TX} <: eMCMC.GlobalWorkspace{T}\n    sub_ws::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    data::TD\n    stats::GenericChainStats{T}\n    XX_buffer::TX\n    pnames::Vector{Symbol}\nend\n\nGlobal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericGlobalSubworkspace from ExtensibleMCMC that stores info           about the parameter chain\nsub_ws_diff: DiffusionGlobalSubworkspace containers for the accepted                diffusion law/paths\nsub_ws_diff°: DiffusionGlobalSubworkspace containers for the proposed                 diffusion law/paths\ndata: observations\nstats::GenericChainStats: generic online statistics for the param chain\nXX_buffer: cache for saving a chain of paths\npnames: a list of parameter names that are being updated\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#Local-workspaces-1","page":"Diffusion Workspaces","title":"Local workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Local workspaces hold information pertinent to particular updates. In particular it collects such information as acceptance history or a history of log-likelihoods.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionLocalSubworkspace\nDiffusionMCMC.DiffusionLocalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalSubworkspace","text":"struct DiffusionLocalSubworkspace{T,TP,TW,TWn,TX,Tz0} <: eMCMC.LocalWorkspace{T}\n    ll::Vector{Float64}\n    ll_history::Vector{Vector{Float64}}\n    P::TP\n    WW::TW\n    Wnr::TWn\n    XX::TX\n    z0s::Tz0\nend\n\nConvenience sub-workspace that holds\n\nll::Vector{Float64}: computational buffer for log-likelihoods (one for each                        recording)\nll_history::Vector{Vector{Float64}}:  history of all log-likelihoods\nP: appropriately shaped views to containers with GuidProps\nWW: appropriately shaped views to containers for sampled Wiener process\nWnr: list of Wiener flags for each recording\nXX: appropriately shaped views to containers for sampled diffusion paths\nz0s: list of white noise for starting points (one for each recording)\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalWorkspace","text":"struct DiffusionLocalWorkspace{T,SW,SWD,Tpr} <: eMCMC.LocalWorkspace{T}\n    sub_ws::SW\n    sub_ws°::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    xx0_priors::Tpr\n    acceptance_history::Vector{Vector{Bool}}\n    loc_pnames::LocalUpdtParamNames\n    critical_param_change::Vector{Bool}\nend\n\nLocal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericLocalSubworkspace from ExtensibleMCMC that acts as a           local cache for some light parameter computations\nsub_ws°: same as sub_ws, but concerns the proposed parameter\nsub_ws_diff: DiffusionLocalSubworkspace, views to containers for the                accepted diffusion law/paths\nsub_ws_diff°: DiffusionLocalSubworkspace, views to containers for the                 proposed diffusion law/paths\nxx0_priors: priors over starting points\nacceptance_history: history of results from the accept/reject                       Metropolis–Hastings step\nloc_pnames: various lists of parameter names helping in performing the               update in a clean way\ncritical_param_change: a list of flags for whether a given update by itself                          prompts for recomputation of the guiding term\n\n\n\n\n\n","category":"type"},{"location":"manual/blocking/#Blocking-1","page":"(TODO) Blocking","title":"Blocking","text":"","category":"section"},{"location":"manual/blocking/#","page":"(TODO) Blocking","title":"(TODO) Blocking","text":"","category":"page"},{"location":"manual/callbacks/#Callbacks-1","page":"(TODO) Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/#","page":"(TODO) Callbacks","title":"(TODO) Callbacks","text":"","category":"page"},{"location":"manual/updates_and_decorators/#manual_start-1","page":"Updates & Decorators","title":"Updates & decorators","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"An important category of updates for DiffusionMCMC.jl are:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.MCMCDiffusionImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.MCMCDiffusionImputation","page":"Updates & Decorators","title":"DiffusionMCMC.MCMCDiffusionImputation","text":"MCMCDiffusionImputation <: MCMCImputation\n\nSupertype of all imputations related to diffusions.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"These are essential for imputing the unobserved parts of the path, as well as sampling the starting point. The following imputation steps have been implemented.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.PathImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.PathImputation","page":"Updates & Decorators","title":"DiffusionMCMC.PathImputation","text":"struct PathImputation{T} <: MCMCDiffusionImputation\n    ρs::Vector{Vector{T}}\n    aux_laws\nend\n\nUpdate type. An indicator for imputation of unobserved path segments. ρs are the memory parameters for the preconditioned Crank–Nicolson scheme and aux_laws are the laws for the auxiliary diffusions.\n\nPathImputation(ρ::T, P) where T<:Number\n\nBase constructor v1. Initialize all ρs with the same value ρ and set auxiliary laws to P.\n\nPathImputation(ρ::T, P) where T<:Vector\n\nBase constructor v2. Initialize each recording with its own value of ρ and set auxiliary laws to P.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/inference_fpt/#Inference-in-a-first-passage-time-setting-1","page":"(TODO) Inference from first-passage time observations","title":"Inference in a first-passage time setting","text":"","category":"section"},{"location":"tutorials/inference_fpt/#","page":"(TODO) Inference from first-passage time observations","title":"(TODO) Inference from first-passage time observations","text":"","category":"page"},{"location":"manual/how_extend/#The-underlying-structure-1","page":"Extension of ExtensibleMCMC.jl","title":"The underlying structure","text":"","category":"section"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"","category":"page"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"DiffusionMCMC.jl is at its core an extension of ExtensibleMCMC.jl. Consequently, the way of interacting with the package follows closely how it was presented in here. In particular, the list of parameter updates remains unchanged, it is merely extended with additional steps pertinent to imputation of the paths.","category":"page"},{"location":"tutorials/conjugate_updates/#Conjugate-updates-for-the-FitzHugh–Nagumo-model-1","page":"(TODO) Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/conjugate_updates/#","page":"(TODO) Conjugate updates for the FitzHugh–Nagumo model","title":"(TODO) Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/mixed_effects_models/#Mixed-effects-models-1","page":"(TODO) Mixed-effect models","title":"Mixed-effects models","text":"","category":"section"},{"location":"tutorials/mixed_effects_models/#","page":"(TODO) Mixed-effect models","title":"(TODO) Mixed-effect models","text":"","category":"page"},{"location":"#DiffusionMCMC.jl-1","page":"Home","title":"DiffusionMCMC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bayesian inference for diffusion processes via MCMC sampling. It's an extension of ExtensibleMCMC.jl to diffusion processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"All algorithms provided in ExtensibleMCMC.jl work here as well and do inference for diffusions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of DiffusionMCMC.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionMCMC.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"tutorials/simple_inference/#tutorials_start-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference and smoothing for the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"In this tutorial we will do smoothing and parameter inference for the partially observed hypoelliptic version of the FitzHugh–Nagumo model.","category":"page"},{"location":"tutorials/simple_inference/#Preparation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Preparation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Before we can start doing smoothing or inference we need to","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"load in the relevant libraries\ngenerate some data\nand finally, decorate the data using ObservationSchemes.jl","category":"page"},{"location":"tutorials/simple_inference/#Prerequisite-libraries-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Prerequisite libraries","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We simply load the necessary tools from JuliaDiffusionBayes and some additional libraries for using StaticArrays, plotting, and defining an ordered dictionary. We may also define alias names for easy access to functions that are not exported, but need to be accessed","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals\nusing DiffusionDefinition, ObservationSchemes\nconst DD = DiffusionDefinition\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Plots\nusing OrderedCollections","category":"page"},{"location":"tutorials/simple_inference/#Simulating-some-data-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Simulating some data","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"For this tutorial we will simulate some artificial data using the FitzHugh–Nagumo model. This diffusion process is already defined in DiffusionDefinition.jl, so we may simply load it in.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"@load_diffusion FitzHughNagumo\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-1.0, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n    x->(x[1], x[2][1] + 0.1randn()),\n    collect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# and let's see how they look\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(getindex.(data, 1), getindex.(data, 2), label=\"data\")","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_data)","category":"page"},{"location":"tutorials/simple_inference/#Data-preparation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Data preparation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The final step before doing smoothing or inference is to arrange the data in a format that will be understood by the MCMC sampler. This is done by decorating each observation with additional information about how it was collected adding information about the underlying law and the starting position, and finally, packaging it as a recording and putting into an AllObservations struct. All of this can be done using the package ObservationSchemes.jl. For more details see [...].","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"recording = (\n    P = P,\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]);\n                L=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/simple_inference/#Smoothing-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Smoothing","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Smoothing is simply sampling of unobserved path-segments according to the diffusion law conditioned on already made observations. To do it we simply need to define an MCMC chain that does imputation of paths and no updates to parameters.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We will need to pass an auxiliary law (think of it as a linear approximation to the target diffusion law) and indicate via backend that we wish to use algorithms from DiffusionMCMC.jl and not only those from ExtensibleMCMC.jl.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# auxiliary law\n@load_diffusion FitzHughNagumoAux\n\n# main definition of an MCMC algorithm\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.96\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = nothing, # no inference\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We will also size a buffer that holds a thinned chain of sampled paths and define a grid-width for sampling diffusion paths.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# some additional parameters for the MCMC chain\nmcmc_kwargs = (\n    path_buffer_size = 10,\n    dt = 0.001,\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can now run the chain.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"It takes about 0.5sec on my laptop...","category":"page"},{"location":"tutorials/simple_inference/#Results-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Results","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The paths are saved in an XX_buffer in a global workspace:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Plotting them is simple enough:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"p = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing)","category":"page"},{"location":"tutorials/simple_inference/#Adaptation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Adaptation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Guessing the right value for the memory parameter ρ of the preconditioned Crank–Nicolson scheme might be tricky. Having a reasonable value for ρ is however essential, as the following example illustrates:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.1\n            PathImputation(0.1, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e4),\n    data = init_obs,\n    θinit = nothing, # no inference\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"This time we set ρ=01 and run the chain for 10 times longer than previously.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"glob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"When we plot the last 10 paths from a thinned chain however, notice what happens:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX\np = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing_poor_pcn)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"It seems that there is only one path! If we inspect the acceptance rate from the last 500 proposals we immediately see what's wrong:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> (sum(loc_ws[1].acceptance_history[end-500:end])/500)[1]\n0.0","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The acceptance rate is 00. We keep proposing new paths but most of them are simply not good enough and we end up staying where we were!","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Finding the right ρ is therefore very important. However, it becomes particularly challenging when the number of recordings grows (and we should guess the right value for each one of those) and when we do parameter inference on top of smoothing (as then, different local values of parameters might have drastically different optimal values for ρ). To alleviate this problem it is possible to employ adaptive schemes that target acceptance rate of the preconditioned Crank–Nicolson scheme and find ρ automatically. To use them, simply pass a relevant flag:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.1\n            PathImputation(\n                0.1, FitzHughNagumoAux;\n                adpt=AdaptationPathImputation(;\n                    adapt_every_k_steps = 50,\n                    scale = 0.2,\n                )\n            ),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e4),\n    data = init_obs,\n    θinit = nothing, # no inference\n)\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"First, notice that the acceptance rate of the last 500 draws looks much more encouraging","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> (sum(ws[2][1].acceptance_history[end-500:end])/500)[1]\n0.252","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Indeed, the chain has started from ρ=01, but over the course of sampling, it reached a region of ρ095–097 and stayed there. The last 10 saved paths look much better now","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX\np = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing_adpt_pcn)","category":"page"},{"location":"tutorials/simple_inference/#Inference-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"If some parameters of the underlying process are unknown, then we may perform inference for it by appending the list of MCMC steps with those that update parameters. Note that the step of imputing the unobserved paths still needs to be present!","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Suppose that we do not know the true value of parameter s and we wish to estimate it. To this end, we first specify the parameters which are constat","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"and re-initialize the data so that an appropriate dependence structure is built internally.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"An important point is revealed by calling:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> ObservationSchemes.print_parameters(init_obs)\n\nThere are 1-many independent recordings.\nThere are also 1-many variable parameters.\n* * *\nYou may define the var-parameters using the following template:\n# start of template\nusing OrderedCollections\n\nθ_init = OrderedDict(\n    :REC1_s => ... , # param 1\n)\n# end of template\nand in an MCMC setting you may let your parameter update step\nrefer to a subset of indices you wish to update using the order\ngiven above.\n* * *","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We should always pass the initial guess for the parameters in the format specified by print_parameters.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can now parameterize the algorithm","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.3]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n        :REC1_s => -0.8,\n        #NOTE currently we must start from the same parameter that was set in AllObservations,\n        #TODO relax this in the near future.\n    ),\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"and run the sampler","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"glob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can plot the chain as follows:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"plot(map(x->x[2][1], glob_ws.sub_ws.state_history))","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_inference_simple_chain)","category":"page"},{"location":"tutorials/simple_inference/#Update-steps-from-[ExtensibleMCMC.jl](https://juliadiffusionbayes.github.io/ExtensibleMCMC.jl/dev/)-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Update steps from ExtensibleMCMC.jl","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"An important thing to mention is that any update from ExtensibleMCMC.jl will work for the parameter update step with diffusions. In particular we may use adaptive schemes:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(\n                UniformRandomWalk([0.01]), [1];\n                adpt=AdaptationUnifRW( # seems that doesn;t work\n                    [0.0];\n                    adapt_every_k_steps=50,\n                    scale=0.05,\n                ),\n            ),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n        :REC1_s => -0.8,\n        #NOTE currently we must start from the same parameter that was set in AllObservations,\n        #TODO relax this in the near future.\n    ),\n)\n\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_inference_adpt_chain)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"but also many others. See [...] for an overview of choices.","category":"page"}]
}
