var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMC]","category":"page"},{"location":"module_index/#DiffusionMCMC.AdaptationPathImputation","page":"Index","title":"DiffusionMCMC.AdaptationPathImputation","text":"mutable struct AdaptationPathImputation <: eMCMC.Adaptation\n    proposed::Int64\n    accepted::Int64\n    target_accpt_rate::Float64\n    adapt_every_k_steps::Int64\n    scale::Float64\n    min::Float64\n    max::Float64\n    offset::Float64\nend\n\nA struct containing information about the way in which to adapt the memory parameter of the preconditioned Crank–Nicolson scheme. proposed and accepted are the internal counters that keep track of the number of proposed and accepted samples. target_accpt_rate is the acceptance rate of the Metropolis-Hastings steps that is supposed to be targetted. min is used to enforce the minimal allowable range that the random walker can sample from, max enforces the maximum. offset introduces some delay in the start of decelerting the adaptation extent and scale is a scaling parameter for adaptation speed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.DiffusionMCMCBackend","page":"Index","title":"DiffusionMCMC.DiffusionMCMCBackend","text":"GenericMCMCBackend\n\nA flag that no specific backend is passed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingChequerboardSwitch","page":"Index","title":"DiffusionMCMC.BlockingChequerboardSwitch","text":"BlockingChequerboardSwitch <: BlockingType\n\nA decorator indicating a switch (in a chequerboard pattern) that changes the locations of delimiters of blocks.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.BlockingType","page":"Index","title":"DiffusionMCMC.BlockingType","text":"BlockingType <: MCMCUpdateDecorator\n\nSupertype of all blocking patterns.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DiffusionMCMC.DiffusionSpecificCallback","page":"Index","title":"DiffusionMCMC.DiffusionSpecificCallback","text":"DiffusionSpecificCallback <: Callback\n\nSupertype of all callbacks specific to diffusion processes.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#DataStructures.reset!-Tuple{AdaptationPathImputation}","page":"Index","title":"DataStructures.reset!","text":"reset!(adpt::AdaptationPathImputation)\n\nReset the number of proposals and accepted samples to zero.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMC.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMC.init_paths!","text":"init_paths!(P, WW, Wnr, XX, data)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMC.φᶜ-Union{Tuple{S}, Tuple{Any,Any,Any,Any,S}, Tuple{Any,Any,Any,Any,S,Any}} where S","page":"Index","title":"DiffusionMCMC.φᶜ","text":"φᶜ(v, θᶜ, t, x, P::S, n=DD.num_non_hypo(S)) where S\n\nRemainder term in the drift after removing φ'θ from it.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate!-Tuple{AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.acceptance_rate!","text":"acceptance_rate!(adpt::AdaptationPathImputation)\n\nDestructive computation of a current acceptance rate that also resets the number of proposals and accepted samples to zeros.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate-Tuple{AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.acceptance_rate","text":"acceptance_rate(adpt::AdaptationPathImputation)\n\nCompute current acceptance rate of the Metropolis-Hastings update step\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.readjust!","page":"Index","title":"ExtensibleMCMC.readjust!","text":"readjust!(\n    imp::PathImputation, adpt::AdaptationPathImputation, mcmc_iter, i=1\n)\n\nAdaptive readjustment for the ith recording of the preconditioned Crank–Nicolson scheme's memory parameter.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.register!-Tuple{Any,AdaptationPathImputation,Bool,Any}","page":"Index","title":"ExtensibleMCMC.register!","text":"register!(updt, adpt::AdaptationPathImputation, accepted::Bool, ::Any)\n\nRegister the result of the acceptance decision in the Metropolis-Hastings step.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.time_to_update-Tuple{Val{true},AdaptationPathImputation}","page":"Index","title":"ExtensibleMCMC.time_to_update","text":"time_to_update(::Val{true}, adpt::AdaptationPathImputation)\n\nReturn true if it's the time to update the memory parameter of the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Get started","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Installation-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionMCMC.jl","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"note: Note\nThe package depends on DiffusionDefinition.jl, ObservationSchemes.jl, GuidedProposals.jl and ExtensibleMCMC.jl neither of which is registered yet. Install them in the same way as DiffusionMCMC.jl.","category":"page"},{"location":"get_started/overview/#Preparation-1","page":"Get started","title":"Preparation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To use the MCMC samplers implemented in DiffusionMCMC.jl you should define a target and auxiliary diffusions using DiffusionDefinition.jl and put your data in the format of AllObservations from ObservationSchemes.jl, for instance:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals, DiffusionDefinition\nusing ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Random, Plots\nusing OrderedCollections\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# let's prepare the data\nrecording = (\n\tP = P,\n\tobs = load_data(\n\t\tObsScheme(\n\t\t\tLinearGsnObs(\n\t\t\t\t0.0, (@SVector [0.0]);\n\t\t\t\tL=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n\t\t\t)\n\t\t),\n\t\tdata\n\t),\n\tt0 = 0.0,\n\tx0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"get_started/overview/#The-underlying-idea-1","page":"Get started","title":"The underlying idea","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Just as in ExtensibleMCMC.jl you may define a variety of MCMC algorithms by deciding on a sequence of updates that constitute each of its steps. You have a verity of options to choose from:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"for updating the parameters of a diffusion you may choose any step from ExtensibleMCMC.jl\nfor imputing the path on the other hand you may choose anything from a set of updates implemented in this package.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define your MCMC algorithm you should simply pass a list of such updates to the MCMC object.","category":"page"},{"location":"get_started/overview/#Smoothing-1","page":"Get started","title":"Smoothing","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Parameters are known and fixed, so simply path an imputation flag PathImputation to MCMC:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :none => -Inf, # no parameters needed for smoothing\n\t),\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Parameter-inference-1","page":"Get started","title":"Parameter inference","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"In addition to imputation step pass a parameter update step to define a suitable Metropolis-within-Gibbs algorithm","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)\n\n# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)\n\n\n# and do the inference\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.2]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n\t    :REC1_s => -0.8, # param 1\n\t),\n    callbacks = eMCMC.Callback[],\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n\tdt = 0.001,\n)\n\n# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"get_started/overview/#Adaptive-schemes-1","page":"Get started","title":"Adaptive schemes","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Blocking-1","page":"Get started","title":"Blocking","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Printing-Callback-1","page":"Get started","title":"Printing Callback","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Plotting-Callback-with-[DiffusionMCMCPlots.jl](https://github.com/JuliaDiffusionBayes/DiffusionMCMCPlots.jl)-1","page":"Get started","title":"Plotting Callback with DiffusionMCMCPlots.jl","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#[ExtensibleMCMC.jl](https://github.com/JuliaDiffusionBayes/ExtensibleMCMC.jl)-functionality-1","page":"Get started","title":"ExtensibleMCMC.jl functionality","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"how_to_guides/smoothing/#how_to_guides_start-1","page":"(TODO) Do smoothing","title":"How to do smoothing?","text":"","category":"section"},{"location":"how_to_guides/smoothing/#","page":"(TODO) Do smoothing","title":"(TODO) Do smoothing","text":"","category":"page"},{"location":"manual/conjugate_updates/#conjugate_updates_explanation-1","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Sometimes a subset of parameters conditioned on the realization of the path admits a representation that is given by one of the standard statistical distributions. This means that no Metropolis–Hastings step needs to be employed for the step of updating such parameters, and instead, they can be simply sampled exactly from their conditional distribution. For the case of diffusions two such cases are most frequently encountered in practice.","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"When a prior for the parameters in the drift is set to be (multivariate) Gaussian, then the distribution of those parameters conditionally on the path X can sometimes be identified as a Gaussian distribution as well. We will refer to this case as conjugate Gaussian updates.\nWhen a prior for the parameters in the volatility coefficient is set to be (multivariate) Gaussian, then the distribution of those parameters conditionally on the path X can sometimes be identified as an Inverse-Wishart distribution. We will refer to this case as conjugate Gaussian-Inverse-Wishart updates (TODO this section needs to be written up and coded up).","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"note: Note\nThe word sometimes is important. It will not be possible to always find conjugate Gaussian updates for any parameters in the drift, nor will it be possible for any parameters in the volatility coefficients we please. They must additionally satisfy certain conditions that we describe below.","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"warning: Warning\nConjugate updates may dramatically improve mixing of the Markov chains; however, for users inexperienced in stochastic analysis this might be a risky option that may potentially yield incorrect results. The reason is that your stochastic differential equation must obey certain principles (which for certain examples can become quite delicate) and if those principles are not satisfied your code might still run and return some answer, but the answer will not be correct. Consequently, we urge the user to exert caution when employing conjugate updates. Below, we try to present the relevant background for employing conjugate updates.","category":"page"},{"location":"manual/conjugate_updates/#Conjugate-Gaussian-updates-1","page":"Conjugate updates","title":"Conjugate Gaussian updates","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"page"},{"location":"manual/conjugate_updates/#Statement-of-the-result-1","page":"Conjugate updates","title":"Statement of the result","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Suppose we have a stochastic differential equation of the form:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"beginalign*\n    dd X_t^1m = β(tX_t)dd t\n    dd X_t^(m+1)d = leftφ(tX_t)θ + ϕ(tX_t)rightdd t + σ(tX_t) dd W_t\nendalign*","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"where the notation cdot^ab is used to represent subvectors. If m=0, then the first row disappears. W denotes a (d-m)-dimensional Wiener process, θinRR^p, φRRtimesRR^dRR^(d-m)timesRR^p and ϕRRtimesRR^dRR^(d-m). Suppose further that θ comes equipped with a multivariate Gaussian prior:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"π(θ)N(μΣ)","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Then, formally, the distribution of the parameters θ conditionally on the realization of the path X is Gaussian:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"π(θX)Nleft(\n    left(mathcalW + Σ^-1right)^-1leftλ + Σ^-1μright\n    left(mathcalW + Σ^-1right)^-1\nright)","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"where","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"λ=int_0^T left\n        φ^Tleft(σσ^Tright)^-1\n    right(tX_t) dd X_t^(m+1)d\n    - int_0^T left\n        φ^Tleft(σσ^Tright)^-1ϕ\n    right(tX_t) dd t","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"and","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"W=int_0^T left\n    φ^Tleft(σσ^Tright)^-1φ\nright(tX_t) dd t","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"note: Note\nThe result is only formal and not rigorous. For it to be rigorous one needs to make sure that the target and the dominating laws are well-defined and that the Radon–Nikodym derivative between the two exists (and is given by the implicitly assumed expression).","category":"page"},{"location":"manual/conjugate_updates/#Coding-conjugate-Gaussian-updates-up-1","page":"Conjugate updates","title":"Coding conjugate Gaussian updates up","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"The major bulk of the computations is already pre-coded in the package; however, the user needs to provide the functions φ and ϕ as well as indicate which coordinates are non-degenerate (in the above the first m coordinates are degenerate; however, in general they can appear at any position and be interlaced with non-degenerate ones, the user needs to simply indicate in a list which ones have non-zero volatility).","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"To help with this process we can use a macro @conjugate_gaussian from the package DiffusionDefinition.jl (see [this page] for the documentation of this macro). To specify which coordinates are non-degenerate pass :nonhypo --> collect((m+1):d) say to @conjugate_gaussian. Function phi should be specified parameter after parameter by passing pairs of parameter-name—φ^i(tx), where parameter-name corresponds to the ith parameter and φ^i(tx) is simply an ith row of φ(tx). Function can be defined directly by overloading","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"DiffusionMCMC.φᶜ","category":"page"},{"location":"manual/conjugate_updates/#DiffusionMCMC.φᶜ","page":"Conjugate updates","title":"DiffusionMCMC.φᶜ","text":"φᶜ(v, θᶜ, t, x, P::S, n=DD.num_non_hypo(S)) where S\n\nRemainder term in the drift after removing φ'θ from it.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"In here, θ^c denotes a vector of parameters other than θ (i.e. parameters assumed to be constant when updating θ), plus a single entry with 1, that represents terms independent from any parameters whatsoever.","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Alternatively, if the remaining parameters θ^c also appear in a linear fashion in the drift, i.e. we have:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"ϕ(txθ^c) = φ^c(tx)θ^c","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"for some function φ^c independent from θ^c, then we may specify the rows of function φ^c as if they were the rows of function φ and as if the parameters θ^c were being updated alongside θ instead of specifying ϕ directly. Then, we can simply indicate which parameters out of (θ θ^c) are actually being updated with conjugate updates.","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Function (σσ^T)^-1 will be computed automatically based on the indicator of a subset of non-degenerate coordinates and based on the global volatility coefficient defining a diffusion process. However, we can speed up these computations by passing an expression for (σσ^T)^-1 directly by passing :hypo_a_inv --> f(t,x,P).","category":"page"},{"location":"manual/conjugate_updates/#Example-1","page":"Conjugate updates","title":"Example","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"Consider a FitzHugh—Nagumo model in a slightly reparameterized form from here. We can define conjugate updates for it as follows:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"@conjugate_gaussian FitzHughNagumoConjug begin\n    :intercept --> (-x[2],)\n    :ϵ --> (x[1]-x[1]^3+(1-3*x[1]^2)*x[2],)\n    :s --> (one(x[1]),)\n    :γ --> (-x[1],)\n    :β --> (-one(x[1]),)\n    :hypo_a_inv --> 1.0/P.σ^2\n    :nonhypo --> 2:2\nend","category":"page"},{"location":"how_to_guides/blocking/#How-to-do-blocking?-1","page":"(TODO) Do blocking","title":"How to do blocking?","text":"","category":"section"},{"location":"how_to_guides/blocking/#","page":"(TODO) Do blocking","title":"(TODO) Do blocking","text":"","category":"page"},{"location":"manual/workspaces/#Workspaces-1","page":"Diffusion Workspaces","title":"Workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Workspaces are containers on which most of the computations done by the MCMC algorithm are performed. It is not important to know how this work is dealt with internally; however, it is helpful to know what are the entries of the global and local workspace for diffusions, as the output of the call to run! is precisely that:","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"the DiffusionGlobalWorkspace, as well as\nDiffusionLocalWorkspace for each update.","category":"page"},{"location":"manual/workspaces/#Global-workspaces-1","page":"Diffusion Workspaces","title":"Global workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Global workspace holds information about the history of the parameters (both accepted and proposed) as well as some standard, already pre-computed statistics about the chain.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionGlobalSubworkspace\nDiffusionMCMC.DiffusionGlobalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalSubworkspace","text":"struct DiffusionGlobalSubworkspace{T,TGP,TW,TWn,TX} <: eMCMC.GlobalWorkspace{T}\n    P::TGP\n    WW::TW\n    Wnr::TWn\n    XX::TX\nend\n\nConvenience sub-workspace that holds\n\nP::Vector{<:Vector{<:GuidProp}}: the GuidProp laws [TODO change to PP or                                    PPP]\nWW::Vector{<:Vector{<:Trajectory}}: the containers for sampling the Wiener                                       noise\nWnr::Vector{<:Wiener}: the flags for the Wiener noise\nXX::Vector{<:Vector{<:Trajectory}}: the containers for sampling the                                       diffusion paths\n\nThe outer array corresponds to successive recordings, the inner arrays correspond to successive observations within each recording. Each DiffusionSubworkspace has two DiffusionGlobalSubworkspaces, one for the accepted law/path another for the proposal.\n\nDiffusionGlobalSubworkspace{T}(\n    aux_laws, data::AllObservations, tts, args,\n) where T\n\nA standard constructor. aux_laws is a list of auxiliary laws (one for each recording), data holds the observations, tts are the time-grids on which to do imputation when sampling and args are additional positional arguments passed to initializers of GuidProp.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionGlobalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionGlobalWorkspace","text":"struct DiffusionGlobalWorkspace{T,SW,SWD,TD,TX} <: eMCMC.GlobalWorkspace{T}\n    sub_ws::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    data::TD\n    stats::GenericChainStats{T}\n    XX_buffer::TX\n    pnames::Vector{Symbol}\nend\n\nGlobal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericGlobalSubworkspace from ExtensibleMCMC that stores info           about the parameter chain\nsub_ws_diff: DiffusionGlobalSubworkspace containers for the accepted                diffusion law/paths\nsub_ws_diff°: DiffusionGlobalSubworkspace containers for the proposed                 diffusion law/paths\ndata: observations\nstats::GenericChainStats: generic online statistics for the param chain\nXX_buffer: cache for saving a chain of paths\npnames: a list of parameter names that are being updated\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#Local-workspaces-1","page":"Diffusion Workspaces","title":"Local workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"Local workspaces hold information pertinent to particular updates. In particular it collects such information as acceptance history or a history of log-likelihoods.","category":"page"},{"location":"manual/workspaces/#","page":"Diffusion Workspaces","title":"Diffusion Workspaces","text":"DiffusionMCMC.DiffusionLocalSubworkspace\nDiffusionMCMC.DiffusionLocalWorkspace","category":"page"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalSubworkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalSubworkspace","text":"struct DiffusionLocalSubworkspace{T,TP,TW,TWn,TX,Tz0} <: eMCMC.LocalWorkspace{T}\n    ll::Vector{Float64}\n    ll_history::Vector{Vector{Float64}}\n    P::TP\n    WW::TW\n    Wnr::TWn\n    XX::TX\n    z0s::Tz0\nend\n\nConvenience sub-workspace that holds\n\nll::Vector{Float64}: computational buffer for log-likelihoods (one for each                        recording)\nll_history::Vector{Vector{Float64}}:  history of all log-likelihoods\nP: appropriately shaped views to containers with GuidProps\nWW: appropriately shaped views to containers for sampled Wiener process\nWnr: list of Wiener flags for each recording\nXX: appropriately shaped views to containers for sampled diffusion paths\nz0s: list of white noise for starting points (one for each recording)\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#DiffusionMCMC.DiffusionLocalWorkspace","page":"Diffusion Workspaces","title":"DiffusionMCMC.DiffusionLocalWorkspace","text":"struct DiffusionLocalWorkspace{T,SW,SWD,Tpr,AH} <: eMCMC.LocalWorkspace{T}\n    sub_ws::SW\n    sub_ws°::SW\n    sub_ws_diff::SWD\n    sub_ws_diff°::SWD\n    xx0_priors::Tpr\n    acceptance_history::Vector{AH}\n    loc_pnames::LocalUpdtParamNames\n    critical_param_change::Vector{Bool}\nend\n\nLocal workspace for MCMC problems concerning diffusions.\n\nArguments\n\nsub_ws: GenericLocalSubworkspace from ExtensibleMCMC that acts as a           local cache for some light parameter computations\nsub_ws°: same as sub_ws, but concerns the proposed parameter\nsub_ws_diff: DiffusionLocalSubworkspace, views to containers for the                accepted diffusion law/paths\nsub_ws_diff°: DiffusionLocalSubworkspace, views to containers for the                 proposed diffusion law/paths\nxx0_priors: priors over starting points\nacceptance_history: history of results from the accept/reject                       Metropolis–Hastings step\nloc_pnames: various lists of parameter names helping in performing the               update in a clean way\ncritical_param_change: a list of flags for whether a given update by itself                          prompts for recomputation of the guiding term\n\n\n\n\n\n","category":"type"},{"location":"manual/blocking/#Blocking-1","page":"(TODO) Blocking","title":"Blocking","text":"","category":"section"},{"location":"manual/blocking/#","page":"(TODO) Blocking","title":"(TODO) Blocking","text":"","category":"page"},{"location":"manual/callbacks/#Callbacks-1","page":"(TODO) Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/#","page":"(TODO) Callbacks","title":"(TODO) Callbacks","text":"","category":"page"},{"location":"manual/updates_and_decorators/#manual_start-1","page":"Updates & Decorators","title":"Updates & decorators","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"An important category of updates for DiffusionMCMC.jl are:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.MCMCDiffusionImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.MCMCDiffusionImputation","page":"Updates & Decorators","title":"DiffusionMCMC.MCMCDiffusionImputation","text":"MCMCDiffusionImputation <: MCMCImputation\n\nSupertype of all imputations related to diffusions.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"These are essential for imputing the unobserved parts of the path, as well as sampling the starting point. The following imputation steps have been implemented.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"DiffusionMCMC.PathImputation","category":"page"},{"location":"manual/updates_and_decorators/#DiffusionMCMC.PathImputation","page":"Updates & Decorators","title":"DiffusionMCMC.PathImputation","text":"struct PathImputation{T} <: MCMCDiffusionImputation\n    ρs::Vector{Vector{T}}\n    aux_laws\nend\n\nUpdate type. An indicator for imputation of unobserved path segments. ρs are the memory parameters for the preconditioned Crank–Nicolson scheme and aux_laws are the laws for the auxiliary diffusions.\n\nPathImputation(ρ::T, P) where T<:Number\n\nBase constructor v1. Initialize all ρs with the same value ρ and set auxiliary laws to P.\n\nPathImputation(ρ::T, P) where T<:Vector\n\nBase constructor v2. Initialize each recording with its own value of ρ and set auxiliary laws to P.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/inference_fpt/#Inference-in-a-first-passage-time-setting-1","page":"(TODO) Inference from first-passage time observations","title":"Inference in a first-passage time setting","text":"","category":"section"},{"location":"tutorials/inference_fpt/#","page":"(TODO) Inference from first-passage time observations","title":"(TODO) Inference from first-passage time observations","text":"","category":"page"},{"location":"manual/how_extend/#The-underlying-structure-1","page":"Extension of ExtensibleMCMC.jl","title":"The underlying structure","text":"","category":"section"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"","category":"page"},{"location":"manual/how_extend/#","page":"Extension of ExtensibleMCMC.jl","title":"Extension of ExtensibleMCMC.jl","text":"DiffusionMCMC.jl is at its core an extension of ExtensibleMCMC.jl. Consequently, the way of interacting with the package follows closely how it was presented in here. In particular, the list of parameter updates remains unchanged, it is merely extended with additional steps pertinent to imputation of the paths.","category":"page"},{"location":"tutorials/conjugate_updates/#Conjugate-updates-for-the-FitzHugh–Nagumo-model-1","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"In this tutorial we will do parameter inference for the partially observed hypoelliptic version of the FitzHugh–Nagumo model using conjugate Gaussian updates.","category":"page"},{"location":"tutorials/conjugate_updates/#Reparameterization-1","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Reparameterization","text":"","category":"section"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"The ordinarily parameterized FitzHugh–Nagumo model:","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"beginalign*\ndd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dd t\ndd X_t = left( gamma Y_t - X_t + beta right )dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"is not ideal for conjugate updates, as parameter ϵ cannot be updated with this method. However, it is possible to slightly reparameterize the model so that three parameters: (ϵsγ) can be updated at once. The reparameterized model is given by the following SDE:","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"and can be loaded in with","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"using DiffusionDefinition\n@load_diffusion FitzHughNagumoConjug","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"For more information about the reparameterization see this page.","category":"page"},{"location":"tutorials/conjugate_updates/#Preparation-1","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Preparation","text":"","category":"section"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"Before we can start doing any inference we should perform the same preparatory steps as we did in the previous tutorial. Thus, before proceeding any further make sure that you've loaded the libraries and simulated the data. Note that the data can be simulated as before:","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"using DiffusionDefinition\nconst DD = DiffusionDefinition\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"i.e. using the original parameterization, or equivalently, using the new one:","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"@load_diffusion FitzHughNagumoConjug\nθ = [10.0, -8.0, 15.0, 0.0, 3.0]","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"Just make sure you transform the starting point accordingly via:","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"left(\n    beginmatrix\n        y_0^(textttnew)\n        x_0^(textttnew)\n    endmatrix\nright) =\n    left(\n        beginmatrix\n        y_0^(textttold)\n        frac1ϵ^(textttold)\n            left\n                y_0^(textttold)\n                -left(y_0^(textttold)right)^3\n                -x_0^(textttold)+s^(textttold)\n            right\n        endmatrix\n    right)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"so that the old point","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"(y_0^(textttold)x_0^(textttold))=(-1-1)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"becomes","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"(y_0^(textttnew)x_0^(textttnew))=(-12)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"Below, we summarize the steps of loading in the libraries, simulating the data and preparing the observations. Note that this time, because we will want to deal with a harder problem of simultaneous estimation of three parameters we will make our lives a little easier and decrease the standard deviation of the noise on the observations by one order of magnitude.","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"# load in all relevant libraries\nusing DiffusionMCMC, ExtensibleMCMC, GuidedProposals\nusing DiffusionDefinition, ObservationSchemes\nconst DD = DiffusionDefinition\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Plots\nusing OrderedCollections, GaussianDistributions\n\n@load_diffusion FitzHughNagumoConjug\n\n# generate some data\nθ = [10.0, -8.0, 15.0, 0.0, 3.0]\nP = FitzHughNagumoConjug(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-1.0, 2.0]\nX = rand(P, tt, y1)\ndata = map(\n    x->(x[1], x[2][1] + 0.01randn()),\n    collect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# and let's see how they look\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(getindex.(data, 1), getindex.(data, 2), label=\"data\")","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"(Image: data)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"tip: Tip\nThe plot above is not very transparent as the ranges of coordinates are not really compatible for displaying on the same plot. One way to deal with this (which has an additional benefit of being more comparable to our previous tutorial) is to transform the second coordinate back to the original parameterization and plot that:plot(X.t, getindex.(X.x, 1), size=(800, 300))\nx_old = -1.0/P.ϵ .* getindex.(X.x, 2) .+ getindex.(X.x, 1) .- getindex.(X.x, 1) .^ 3 .+ P.s/P.ϵ\nplot!(X.t, x_old)(Image: data_in_orig_param)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"# finally, prepare the data\nrecording = (\n    P = P,\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]);\n                L=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [1e-4])\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/conjugate_updates/#Inference-1","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Inference","text":"","category":"section"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"\n@load_diffusion FitzHughNagumoConjugAuxSimple\n\nDD.const_parameter_names(::Type{<:FitzHughNagumoConjug}) = (:β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoConjugAuxSimple}) = (:σ, :t0, :T, :vT, :xT)\n\n# and do the inference\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(\n                0.99, FitzHughNagumoConjugAuxSimple;\n                adpt=AdaptationPathImputation(;\n                    adapt_every_k_steps = 50,\n                    scale = 0.05,\n                ),\n            ),\n            DiffusionConjugGsnUpdate(\n                [1,2,3],\n                Gaussian(\n                    (@SVector [0.0, 0.0, 0.0]),\n                    SDiagonal(1e4, 1e4, 1e4),\n                ),\n            )\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e5),\n    data = initialize(observs)[1],\n    θ_init = OrderedDict(\n        :REC1_ϵ => 10.0 , # param 1\n        :REC1_γ => 15.0 , # param 2\n        :REC1_s => -8.0 , # param 3\n    ),\n)\n\nmcmc_kwargs = (\n    path_buffer_size = 10,\n    dt = 0.001,\n)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"# run the MCMC\n@time ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"It takes about 1min 30sec to run on my laptop.","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"# inspect the results\nθθ = [map(x->x[2][i], ws[1].sub_ws.state_history) for i in 1:3]\nplot(θθ, layout=(3,1))\nplot!([[0,1e5], [0,1e5], [0,1e5]], [[10, 10], [15, 15], [-8,-8]])","category":"page"},{"location":"tutorials/conjugate_updates/#","page":"Conjugate updates for the FitzHugh–Nagumo model","title":"Conjugate updates for the FitzHugh–Nagumo model","text":"(Image: chains)","category":"page"},{"location":"tutorials/mixed_effects_models/#Mixed-effects-models-1","page":"(TODO) Mixed-effect models","title":"Mixed-effects models","text":"","category":"section"},{"location":"tutorials/mixed_effects_models/#","page":"(TODO) Mixed-effect models","title":"(TODO) Mixed-effect models","text":"","category":"page"},{"location":"#DiffusionMCMC.jl-1","page":"Home","title":"DiffusionMCMC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bayesian inference for diffusion processes via MCMC sampling. It's an extension of ExtensibleMCMC.jl to diffusion processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"All algorithms provided in ExtensibleMCMC.jl work here as well and do inference for diffusions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of DiffusionMCMC.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionMCMC.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"tutorials/simple_inference/#tutorials_start-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference and smoothing for the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"In this tutorial we will do smoothing and parameter inference for the partially observed hypoelliptic version of the FitzHugh–Nagumo model.","category":"page"},{"location":"tutorials/simple_inference/#Preparation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Preparation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Before we can start doing smoothing or inference we need to","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"load in the relevant libraries\ngenerate some data\nand finally, decorate the data using ObservationSchemes.jl","category":"page"},{"location":"tutorials/simple_inference/#Prerequisite-libraries-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Prerequisite libraries","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We simply load the necessary tools from JuliaDiffusionBayes and some additional libraries for using StaticArrays, plotting, and defining an ordered dictionary. We may also define alias names for easy access to functions that are not exported, but need to be accessed","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"using DiffusionMCMC, ExtensibleMCMC, GuidedProposals\nusing DiffusionDefinition, ObservationSchemes\nconst DD = DiffusionDefinition\nconst eMCMC = ExtensibleMCMC\n\nusing StaticArrays, Plots\nusing OrderedCollections","category":"page"},{"location":"tutorials/simple_inference/#Simulating-some-data-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Simulating some data","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"For this tutorial we will simulate some artificial data using the FitzHugh–Nagumo model. This diffusion process is already defined in DiffusionDefinition.jl, so we may simply load it in.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"@load_diffusion FitzHughNagumo\n\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-1.0, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n    x->(x[1], x[2][1] + 0.1randn()),\n    collect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\n# and let's see how they look\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(getindex.(data, 1), getindex.(data, 2), label=\"data\")","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_data)","category":"page"},{"location":"tutorials/simple_inference/#Data-preparation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Data preparation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The final step before doing smoothing or inference is to arrange the data in a format that will be understood by the MCMC sampler. This is done by decorating each observation with additional information about how it was collected adding information about the underlying law and the starting position, and finally, packaging it as a recording and putting into an AllObservations struct. All of this can be done using the package ObservationSchemes.jl. For more details see [...].","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"recording = (\n    P = P,\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]);\n                L=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)\nobservs = AllObservations()\nadd_recording!(observs, recording)\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/simple_inference/#Smoothing-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Smoothing","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Smoothing is simply sampling of unobserved path-segments according to the diffusion law conditioned on already made observations. To do it we simply need to define an MCMC chain that does imputation of paths and no updates to parameters.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We will need to pass an auxiliary law (think of it as a linear approximation to the target diffusion law) and indicate via backend that we wish to use algorithms from DiffusionMCMC.jl and not only those from ExtensibleMCMC.jl.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# auxiliary law\n@load_diffusion FitzHughNagumoAux\n\n# main definition of an MCMC algorithm\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.96\n            PathImputation(0.96, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = nothing, # no inference\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We will also size a buffer that holds a thinned chain of sampled paths and define a grid-width for sampling diffusion paths.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# some additional parameters for the MCMC chain\nmcmc_kwargs = (\n    path_buffer_size = 10,\n    dt = 0.001,\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can now run the chain.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# run the MCMC\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"It takes about 0.5sec on my laptop...","category":"page"},{"location":"tutorials/simple_inference/#Results-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Results","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The paths are saved in an XX_buffer in a global workspace:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Plotting them is simple enough:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"p = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing)","category":"page"},{"location":"tutorials/simple_inference/#Adaptation-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Adaptation","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Guessing the right value for the memory parameter ρ of the preconditioned Crank–Nicolson scheme might be tricky. Having a reasonable value for ρ is however essential, as the following example illustrates:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.1\n            PathImputation(0.1, FitzHughNagumoAux),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e4),\n    data = init_obs,\n    θinit = nothing, # no inference\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"This time we set ρ=01 and run the chain for 10 times longer than previously.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"glob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"When we plot the last 10 paths from a thinned chain however, notice what happens:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX\np = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing_poor_pcn)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"It seems that there is only one path! If we inspect the acceptance rate from the last 500 proposals we immediately see what's wrong:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> (sum(loc_ws[1].acceptance_history[end-500:end])/500)[1]\n0.0","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"The acceptance rate is 00. We keep proposing new paths but most of them are simply not good enough and we end up staying where we were!","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Finding the right ρ is therefore very important. However, it becomes particularly challenging when the number of recordings grows (and we should guess the right value for each one of those) and when we do parameter inference on top of smoothing (as then, different local values of parameters might have drastically different optimal values for ρ). To alleviate this problem it is possible to employ adaptive schemes that target acceptance rate of the preconditioned Crank–Nicolson scheme and find ρ automatically. To use them, simply pass a relevant flag:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            # sampling of paths with a precond. Crank–Nicolson parameter ρ=0.1\n            PathImputation(\n                0.1, FitzHughNagumoAux;\n                adpt=AdaptationPathImputation(;\n                    adapt_every_k_steps = 50,\n                    scale = 0.2,\n                )\n            ),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e4),\n    data = init_obs,\n    θinit = nothing, # no inference\n)\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"First, notice that the acceptance rate of the last 500 draws looks much more encouraging","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> (sum(ws[2][1].acceptance_history[end-500:end])/500)[1]\n0.252","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Indeed, the chain has started from ρ=01, but over the course of sampling, it reached a region of ρ095–097 and stayed there. The last 10 saved paths look much better now","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"xs = glob_ws.XX_buffer.XX\np = plot(size=(800, 300))\nfor i in 1:10\n    plot!(p, xs[i][1], Val(:vs_time), color=[\"red\" \"steelblue\"], label=false, alpha=0.4)\nend\nscatter!(p, getindex.(data, 1), getindex.(data, 2), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_smoothing_adpt_pcn)","category":"page"},{"location":"tutorials/simple_inference/#Inference-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"If some parameters of the underlying process are unknown, then we may perform inference for it by appending the list of MCMC steps with those that update parameters. Note that the step of imputing the unobserved paths still needs to be present!","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"Suppose that we do not know the true value of parameter s and we wish to estimate it. To this end, we first specify the parameters which are constat","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"and re-initialize the data so that an appropriate dependence structure is built internally.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"# and initialize for those constant parameters\ninit_obs, _ = initialize(observs)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"An important point is revealed by calling:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"julia> ObservationSchemes.print_parameters(init_obs)\n\nThere are 1-many independent recordings.\nThere are also 1-many variable parameters.\n* * *\nYou may define the var-parameters using the following template:\n# start of template\nusing OrderedCollections\n\nθ_init = OrderedDict(\n    :REC1_s => ... , # param 1\n)\n# end of template\nand in an MCMC setting you may let your parameter update step\nrefer to a subset of indices you wish to update using the order\ngiven above.\n* * *","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We should always pass the initial guess for the parameters in the format specified by print_parameters.","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can now parameterize the algorithm","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(UniformRandomWalk([0.3]), [1]),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n        :REC1_s => -0.8,\n        #NOTE currently we must start from the same parameter that was set in AllObservations,\n        #TODO relax this in the near future.\n    ),\n)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"and run the sampler","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"glob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"We can plot the chain as follows:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"plot(map(x->x[2][1], glob_ws.sub_ws.state_history))","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_inference_simple_chain)","category":"page"},{"location":"tutorials/simple_inference/#Update-steps-from-[ExtensibleMCMC.jl](https://juliadiffusionbayes.github.io/ExtensibleMCMC.jl/dev/)-1","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Update steps from ExtensibleMCMC.jl","text":"","category":"section"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"An important thing to mention is that any update from ExtensibleMCMC.jl will work for the parameter update step with diffusions. In particular we may use adaptive schemes:","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            PathImputation(0.96, FitzHughNagumoAux),\n            RandomWalkUpdate(\n                UniformRandomWalk([0.01]), [1];\n                adpt=AdaptationUnifRW( # seems that doesn;t work\n                    [0.0];\n                    adapt_every_k_steps=50,\n                    scale=0.05,\n                ),\n            ),\n        ];\n        backend=DiffusionMCMCBackend(),\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = init_obs,\n    θinit = OrderedDict(\n        :REC1_s => -0.8,\n        #NOTE currently we must start from the same parameter that was set in AllObservations,\n        #TODO relax this in the near future.\n    ),\n)\n\nglob_ws, loc_ws = run!(mcmc_params...; mcmc_kwargs...)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"(Image: fhn_inference_adpt_chain)","category":"page"},{"location":"tutorials/simple_inference/#","page":"Inference & smoothing for the FitzHugh–Nagumo model","title":"Inference & smoothing for the FitzHugh–Nagumo model","text":"but also many others. See [...] for an overview of choices.","category":"page"}]
}
